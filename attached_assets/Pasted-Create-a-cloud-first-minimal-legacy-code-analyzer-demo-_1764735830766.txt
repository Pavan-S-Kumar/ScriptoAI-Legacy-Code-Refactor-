Create a cloud-first, minimal legacy-code-analyzer demo using the following stack and files:

Tech: HTML/CSS/JS (frontend), Python FastAPI (backend), Flask runner (minimal), SQLite for job storage, n8n workflow for orchestration. No React.

Goal

User uploads a repo ZIP or pastes a GitHub URL. Backend forwards to n8n webhook, n8n calls runner which returns JSON results, n8n posts results to backend /callback, frontend polls /status/{request_id} and displays results.

Files to create (exact paths & content summary)
1. frontend/index.html

Simple upload form (file or GitHub URL), analysis-mode selector, status area. Should load styles.css and app.js.

2. frontend/styles.css

Minimal styling for neat demo UI.

3. frontend/app.js

Submit form to /analyze on same origin (POST form-data: code_zip, repo_url, analysis_mode).

Receive JSON { request_id }.

Poll /status/{request_id} every 2s until status becomes completed or failed.

Show returned JSON in a <pre>.

4. backend/main.py (FastAPI)

Endpoints:

POST /analyze accepts code_zip (file) or repo_url (form), analysis_mode (form). Generates request_id and stores job in jobs.db. Forwards payload (file + form fields) to n8n webhook.

POST /callback accepts JSON from n8n: must include callback_secret and request_id, validates secret, stores final JSON in DB and sets job status.

GET /status/{request_id} returns job status and results (if available).

Use SQLite (jobs.db) to store jobs (table: id, status, created_at, updated_at, repo_url, results_json).

Env vars (must be read from environment):

N8N_WEBHOOK — NOTE: set to your n8n webhook URL (e.g. https://<n8n-host>/webhook/legacy-analyze)

CALLBACK_SECRET — NOTE: set same secret in n8n Prepare Callback node

EXTERNAL_BASE — NOTE: public backend base URL (e.g. https://<your-replit>.repl.co)

Use python-multipart, requests, fastapi, uvicorn.

5. runner/app.py (Flask) — minimal demo runner

POST /run-analysis receives request_id, analysis_mode, repo_url, optional code_zip (multipart).

For demo returns a small JSON shaping:

{
 "request_id":"req-xxxx",
 "status":"completed",
 "summary":{ "languages":["python"], "total_files_analyzed":1, "issues_count":{"critical":0,"major":0,"minor":1}, ... },
 "issues":[ {...} ],
 "patches":[],
 "verification": {"tests_run":0,"passed":0,"failed":0,"logs":""}
}


NOTE: this is a placeholder — later replace with actual semgrep/pylint/pytest logic inside Docker runner.

6. README.md

Short setup & deploy instructions, environment variables list, and where to paste n8n webhook and secrets.

n8n workflow (instructions — builder will import in n8n Cloud)

Give these exact nodes and settings in n8n:

Webhook (POST)

Path: legacy-analyze

Response Mode: On Received

Accepts form-data fields: request_id, analysis_mode, repo_url, callback_url, callback_secret, binary code_zip.

Write Binary File (optional)

fileName: ={{ $binary?.code_zip ? $binary.code_zip.fileName : '' }}

dataPropertyName: binaryData

(Optional) Upload file to runner — HTTP Request (multipart)

URL: https://RUNNER_HOST/upload — NOTE: replace RUNNER_HOST with your runner URL

Call Runner — HTTP Request (POST JSON)

URL: https://RUNNER_HOST/run-analysis — NOTE: replace RUNNER_HOST

bodyParametersJson:

={
  "request_id": $json["request_id"],
  "analysis_mode": $json["analysis_mode"],
  "repo_url": $json["repo_url"] || "",
  "file_url": $node["Write Binary File"] ? $node["Write Binary File"].binaryData?.[0]?.filePath || "" : ""
}


Timeout ≥ 120s

(Optional) Gemini/LLM — HTTP Request or n8n LLM node

Use runner JSON to produce explanations[] & test_skeletons[]. Store Gemini key in n8n credentials. Temperature 0–0.2.

Prepare Callback Payload — Set node

callback_secret = CALLBACK_SECRET_PLACEHOLDER NOTE: replace with backend secret

request_id = ={{ $json["request_id"] }}

status = ={{ $node["Call Runner"].json["status"] || "completed" }}

results = ={{ $node["Call Runner"].json }}

POST Callback — HTTP Request

URL: ={{ $json["callback_url"] || "https://YOUR_BACKEND_HOST/callback" }} NOTE: replace backend callback URL

Body JSON:

{
  "callback_secret": $node["Prepare Callback Payload"].json["callback_secret"],
  "request_id": $node["Prepare Callback Payload"].json["request_id"],
  "status": $node["Prepare Callback Payload"].json["status"],
  "results": $node["Prepare Callback Payload"].json["results"]
}


Error handling: ensure failures still POST a status: "failed" payload.

Replace placeholders:

RUNNER_HOST → runner URL (e.g., https://legacy-runner.onrender.com)

CALLBACK_SECRET_PLACEHOLDER → same value as backend CALLBACK_SECRET

https://YOUR_BACKEND_HOST/callback → backend public callback URL (e.g., https://<your-replit>.repl.co/callback)

Gemini key stored in n8n credentials if used.

Environment variables (must set in Replit / host)

N8N_WEBHOOK = your n8n webhook URL. NOTE: set this before running backend.

CALLBACK_SECRET = shared secret string.

EXTERNAL_BASE = your backend public base URL.

(Optional) GEMINI_API_KEY stored in n8n credentials.

How to test (quick steps)

Deploy runner (Render/Heroku) — get RUNNER_HOST. (Or use Replit for runner in demo.)

Deploy backend on Replit; set env vars (N8N_WEBHOOK, CALLBACK_SECRET, EXTERNAL_BASE). NOTE: N8N_WEBHOOK must point to the webhook you create in n8n.

Import workflow into n8n Cloud and update Call Runner URL and Prepare Callback Payload secret. Activate workflow.

Host frontend (same Replit app or static host). Open UI, upload a tiny ZIP or paste GitHub URL and start analysis.

Frontend polls /status/{request_id} and displays final JSON result when backend receives callback.

Minimal required tools & runtime (cloud)

Replit account (recommended) or other host for frontend + backend

n8n Cloud account (recommended) or self-hosted n8n

Runner host (Render/Heroku/Railway) for executing analyzers (demo runner is fine initially)

Python 3.10+, pip, Docker if you later containerize runner

Security notes (must follow)

Runner must run real analyzers inside a sandbox (Docker) and block network when executing untrusted code. For demo use placeholder runner only.

Store secrets in environment variables or n8n credentials; never hardcode keys in workflow Set nodes.

Use HTTPS for all endpoints.

Deliverables from Replit (what to hand me)

Project with frontend/, backend/, runner/ files committed.

README.md with steps to set env vars and deploy.

A small demo sample repo in demo-repos/ to test flow.